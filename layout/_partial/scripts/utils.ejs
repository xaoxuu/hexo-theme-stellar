<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      // 倒序遍历避免 splice 后的索引问题
      for (let index = this.list.length - 1; index >= 0; index--) {
        const e = this.list[index];
        if (e.name === name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 已加载脚本缓存
    _loadedScripts: new Set(),

    // 已加载元素缓存 (使用 WeakSet 追踪元素实例,避免 PJAX 导航时的状态混淆)
    _loadedElements: new WeakSet(),

    js: (src, opt) => new Promise((resolve, reject) => {
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      // 如果脚本已加载，直接返回
      if (utils._loadedScripts.has(src)) {
        resolve();
        return;
      }
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        utils._loadedScripts.add(src);
        resolve()
      }
      document.head.appendChild(script)
    }),

    // PJAX 事件监听器管理
    _pjaxListeners: new Set(),
    
    jq: (fn, pjax = true) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
      if (pjax && !fn._pjax_registered) {
        document.addEventListener('pjax:complete', fn);
        fn._pjax_registered = true;
        utils._pjaxListeners.add(fn); // 追踪监听器以便清理
      }
    },
    
    // 清理所有 PJAX 事件监听器
    cleanupPjaxListeners: () => {
      utils._pjaxListeners.forEach(fn => {
        document.removeEventListener('pjax:complete', fn);
        fn._pjax_registered = false;
      });
      utils._pjaxListeners.clear();
    },

    onLoading: (el) => {
      if (el) {
        if ($(el).find('.loading-wrap').length === 0){
          $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
        }
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      // 检查元素实例是否已加载 (而不是检查属性)
      if (el && utils._loadedElements.has(el)) {
        return;
      }
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            // 标记元素实例为已加载
            if (el) utils._loadedElements.add(el);
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},

    // 插件初始化管理器 - 统一处理 DOMContentLoaded 和 pjax:complete 事件
    _pluginInitializers: [],
    _pluginCleanups: new Map(), // 存储每个插件的清理函数
    
    initPlugin: (initFn, name, options = {}) => {
      if (!initFn || typeof initFn !== 'function') return;
      
      // 避免重复注册
      const pluginName = name || initFn.name;
      if (utils._pluginInitializers.some(p => p.name === pluginName)) return;
      
      // 包装初始化函数，添加防重复执行的保护
      const wrappedInit = () => {
        try {
          // 在执行前先清理旧的资源
          if (utils._pluginCleanups.has(pluginName)) {
            const cleanup = utils._pluginCleanups.get(pluginName);
            if (typeof cleanup === 'function') {
              cleanup();
            }
          }
          
          // 执行初始化，可能返回清理函数
          const cleanup = initFn();
          
          // 如果初始化函数返回了清理函数，保存它
          if (typeof cleanup === 'function') {
            utils._pluginCleanups.set(pluginName, cleanup);
          }
        } catch (error) {
          console.error(`[Plugin ${pluginName}] 初始化失败:`, error);
        }
      };
      
      utils._pluginInitializers.push({ 
        fn: wrappedInit, 
        name: pluginName,
        options: options 
      });
      
      // 如果 DOM 已经加载完成，立即执行
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        wrappedInit();
      } else {
        // 否则等待 DOMContentLoaded
        window.addEventListener('DOMContentLoaded', wrappedInit, { once: true });
      }
    },

    // 重新初始化所有插件（用于 PJAX 等场景）
    reinitPlugins: () => {
      utils._pluginInitializers.forEach(plugin => {
        // 跳过标记为不需要重新初始化的插件
        if (plugin.options.skipReinit) return;
        
        try {
          plugin.fn();
        } catch (error) {
          console.error(`[Plugin ${plugin.name}] 重新初始化失败:`, error);
        }
      });
    },
    
    // 清理所有插件资源
    cleanupPlugins: () => {
      utils._pluginCleanups.forEach((cleanup, name) => {
        try {
          cleanup();
        } catch (error) {
          console.error(`[Plugin ${name}] 清理失败:`, error);
        }
      });
      utils._pluginCleanups.clear();
    },
    
    // 清理所有资源（用于页面卸载或重置）
    cleanupAll: () => {
      utils.cleanupPlugins();
      utils.cleanupPjaxListeners();
    },
  };

  // 自动处理 PJAX 事件
  document.addEventListener('pjax:before', () => {
    // 在导航前清理旧的 PJAX 监听器（如果需要重新注册）
    // 注意：这里不清理，因为监听器应该是持久的
    // utils.cleanupPjaxListeners();
  });
  
  document.addEventListener('pjax:complete', () => {
    utils.reinitPlugins();
  });

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>